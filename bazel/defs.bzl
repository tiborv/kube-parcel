"""kube-parcel Bazel rules for Helm chart integration testing.

This module provides rules for running Helm chart tests in ephemeral K3s clusters.
Images can be provided as oci_load targets or any target that provides .tar files.

Exec mode can be toggled via .bazelrc config:
    bazel test --config=docker //...  # Local Docker mode (default)
    bazel test --config=k8s //...     # Kubernetes mode
"""

# ================================
# Rule Implementation
# ================================

def _kube_parcel_test_impl(ctx):
    """Implementation of kube_parcel_test rule."""

    # Collect all inputs
    runfiles_files = []
    chart_paths = []
    image_tarballs = []

    # Process chart directories
    for chart in ctx.attr.charts:
        # Get all files from the chart filegroup/directory
        for f in chart.files.to_list():
            runfiles_files.append(f)

        # Use the first file's dirname as the chart path
        files_list = chart.files.to_list()
        if files_list:
            # Find Chart.yaml to determine chart root
            for f in files_list:
                if f.basename == "Chart.yaml":
                    chart_paths.append(f.dirname)
                    break

    # Process OCI images - collect their tarballs
    for img in ctx.attr.images:
        # oci_load/oci_tarball outputs are in DefaultInfo
        for f in img.files.to_list():
            if f.path.endswith(".tar"):
                image_tarballs.append(f)
                runfiles_files.append(f)

    # Determine exec mode from attribute
    exec_mode = ctx.attr.exec_mode

    # Build the test script (using % substitution to avoid brace escaping issues)
    script_template = """#!/bin/bash
set -e

# kube-parcel test runner
# Generated by kube_parcel_test rule

EXEC_MODE="%s"
KEEP_ALIVE="%s"
NO_AIRGAP="%s"
RUNNER_IMAGE_LOADER="%s"
RUNNER_TAG="%s"

# Chart directories (relative to runfiles)
CHART_DIRS=(%s)

# Image tarballs to load
IMAGE_TARBALLS=(%s)

# Load runner image if provided
if [ -n "$RUNNER_IMAGE_LOADER" ]; then
    echo "üê≥ Loading runner image..."
    if [ -f "$RUNNER_IMAGE_LOADER/load.sh" ]; then
       LOADER="$RUNNER_IMAGE_LOADER/load.sh"
    elif [ -f "$RUNNER_IMAGE_LOADER" ]; then
       LOADER="$RUNNER_IMAGE_LOADER"
    else
       # Fallback find
       LOADER=$(find "$RUNNER_IMAGE_LOADER" -name "load.sh" -type f -o -name "load" -type f | head -n 1)
    fi

    if [ -n "$LOADER" ] && [ -x "$LOADER" ]; then
        "$LOADER"
    elif [ -n "$LOADER" ]; then
        bash "$LOADER"
    else
        echo "‚ö†Ô∏è Could not find executable loader in $RUNNER_IMAGE_LOADER"
    fi
fi

# Build kube-parcel arguments
ARGS=("start")
ARGS+=("--exec-mode" "$EXEC_MODE")

if [ "$KEEP_ALIVE" = "true" ]; then
    ARGS+=("--keep-alive")
fi

if [ "$NO_AIRGAP" = "true" ]; then
    ARGS+=("--no-airgap")
fi

if [ -n "$RUNNER_TAG" ]; then
    ARGS+=("--runner-image" "$RUNNER_TAG")
fi

# Add image tarballs
for tarball in "${IMAGE_TARBALLS[@]}"; do
    if [ -n "$tarball" ]; then
        ARGS+=("--load-images" "$tarball")
    fi
done

# Add chart directories
for chart in "${CHART_DIRS[@]}"; do
    if [ -n "$chart" ]; then
        ARGS+=("$chart")
    fi
done

echo "üöÄ Running kube-parcel test..."
echo "   Exec mode: $EXEC_MODE"
echo "   Charts: ${CHART_DIRS[*]}"
echo "   Images: ${IMAGE_TARBALLS[*]}"
echo ""

# Execute kube-parcel
exec "%s" "${ARGS[@]}"
"""

    runner_image_path = ctx.attr.runner_image.files.to_list()[0].short_path if ctx.attr.runner_image else ""
    runner_tag = ctx.attr.runner_tag if ctx.attr.runner_tag else ""
    chart_dirs_str = " ".join(['"{}"'.format(p) for p in chart_paths])
    image_tarballs_str = " ".join(['"{}"'.format(f.short_path) for f in image_tarballs])
    client_path = ctx.executable._client.short_path

    script_content = script_template % (
        exec_mode,
        "true" if ctx.attr.keep_alive else "false",
        "true" if ctx.attr.no_airgap else "false",
        runner_image_path,
        runner_tag,
        chart_dirs_str,
        image_tarballs_str,
        client_path,
    )

    # Write the test script
    script = ctx.actions.declare_file(ctx.label.name + "_test.sh")
    ctx.actions.write(
        output = script,
        content = script_content,
        is_executable = True,
    )

    # Add client binary to runfiles
    runfiles_files.append(ctx.executable._client)

    # Add runner image files to runfiles
    if ctx.attr.runner_image:
        for f in ctx.attr.runner_image.files.to_list():
            runfiles_files.append(f)

    # Create runfiles
    runfiles = ctx.runfiles(files = runfiles_files)
    runfiles = runfiles.merge(ctx.attr._client[DefaultInfo].default_runfiles)

    if ctx.attr.runner_image:
        runfiles = runfiles.merge(ctx.attr.runner_image[DefaultInfo].default_runfiles)

    return [
        DefaultInfo(
            executable = script,
            runfiles = runfiles,
        ),
    ]

# ================================
# Internal Rule (with fixed exec_mode)
# ================================

_kube_parcel_test = rule(
    implementation = _kube_parcel_test_impl,
    test = True,
    attrs = {
        "charts": attr.label_list(
            mandatory = True,
            allow_files = True,
            doc = "List of Helm chart directories to test. Each label should point to a filegroup or directory containing Chart.yaml.",
        ),
        "images": attr.label_list(
            mandatory = False,
            default = [],
            doc = "List of oci_load/oci_tarball targets to load into the test cluster.",
        ),
        "exec_mode": attr.string(
            mandatory = True,
            values = ["docker", "k8s"],
            doc = "Execution mode: 'docker' for local Docker, 'k8s' for Kubernetes cluster.",
        ),
        "keep_alive": attr.bool(
            default = False,
            doc = "Keep the test container running after failure for debugging.",
        ),
        "no_airgap": attr.bool(
            default = False,
            doc = "Disable airgap mode, allowing K3s to pull external images.",
        ),
        "runner_image": attr.label(
            mandatory = False,
            allow_files = True,
            doc = "Optional oci_load target for the runner image. If provided, it will be loaded into Docker before the test.",
        ),
        "runner_tag": attr.string(
            mandatory = False,
            doc = "Tag of the runner image to use (e.g., 'kube-parcel:latest'). Required if runner_image is set.",
        ),
        "_client": attr.label(
            default = "//cmd/client",
            executable = True,
            cfg = "exec",
            doc = "The kube-parcel client binary.",
        ),
    },
    doc = "Internal rule - use kube_parcel_test macro instead.",
)

# ================================
# Public Macro (supports config-based exec_mode)
# ================================

def kube_parcel_test(
        name,
        charts,
        images = [],
        exec_mode = None,
        keep_alive = False,
        no_airgap = False,
        runner_image = None,
        runner_tag = None,
        **kwargs):
    """Run Helm chart integration tests in an ephemeral K3s cluster.

    This macro launches kube-parcel to create an isolated K3s environment,
    deploys the specified Helm charts with pre-loaded container images,
    and runs Helm tests.

    The exec_mode can be set explicitly or toggled via .bazelrc config:
        bazel test --config=docker //...  # Local Docker mode (default)
        bazel test --config=k8s //...     # Kubernetes mode

    Args:
        name: Test target name
        charts: List of Helm chart directories (labels to filegroups containing Chart.yaml)
        images: List of oci_load/oci_tarball targets to load into the test cluster
        exec_mode: Execution mode override. If None, uses config setting (docker by default).
                   Set to "docker" for local Docker daemon, "k8s" for Kubernetes pod.
        keep_alive: Keep the test container running after failure for debugging
        no_airgap: Disable airgap mode, allowing K3s to pull external images
        runner_image: Optional oci_load target for the runner image used by Docker mode
        runner_tag: Tag for the runner image (required if runner_image is set)
        **kwargs: Additional arguments passed to the underlying test rule (e.g., tags, size)

    Example:
        kube_parcel_test(
            name = "with_custom_runner",
            charts = ["..."],
            runner_image = "//cmd/runner:load",
            runner_tag = "kube-parcel:latest",
        )
    """

    # If exec_mode is not explicitly set, use select() for config-based switching
    if exec_mode == None:
        resolved_exec_mode = select({
            "//bazel:exec_mode_k8s": "k8s",
            "//bazel:exec_mode_docker": "docker",
            "//conditions:default": "docker",
        })
    else:
        resolved_exec_mode = exec_mode

    _kube_parcel_test(
        name = name,
        charts = charts,
        images = images,
        exec_mode = resolved_exec_mode,
        keep_alive = keep_alive,
        no_airgap = no_airgap,
        runner_image = runner_image,
        runner_tag = runner_tag,
        **kwargs
    )

# ================================
# Convenience Macros
# ================================

def kube_parcel_test_suite(name, charts, images = [], **kwargs):
    """Create a test target for each chart.

    This is a convenience macro that creates individual kube_parcel_test
    targets for each chart, useful when you want isolated test results.

    Args:
        name: Base name for the test suite
        charts: List of chart labels
        images: List of oci_load/oci_tarball targets (shared across all tests)
        **kwargs: Additional arguments passed to each kube_parcel_test
    """
    tests = []
    for i, chart in enumerate(charts):
        test_name = "{}_{}".format(name, i)
        kube_parcel_test(
            name = test_name,
            charts = [chart],
            images = images,
            **kwargs
        )
        tests.append(test_name)

    # Create a test_suite that groups all tests
    native.test_suite(
        name = name,
        tests = [":" + t for t in tests],
    )
